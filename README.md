CScript: A Modern Compiler Built with Rust
Project Vision

CScript began as a C compiler, but its goal is to transcend C. By borrowing design philosophies from modern languages like Rust, we are committed to evolving CScript into a syntactically modern, type-safe, and developer-friendly systems programming language.

This project is built from scratch in Rust, integrating a world-class toolchain for modern compiler development with the goal of reaching an industrial-grade standard:

    Lexical Analysis: logos - A blazingly fast lexer generator.

    Syntactic Analysis: chumsky - An expressive and powerful parser combinator library.

    Semantic Analysis: A hand-written visitor pattern with context-driven type resolution.

    Code Generation: inkwell - A safe Rust wrapper for LLVM.

    Error Reporting: ariadne - For generating beautiful and precise compiler diagnostics.

The project has successfully implemented a complete compilation pipeline from source code to native executables, featuring a robust, end-to-end error reporting system.
Compiler Status & Language Features

CScript has evolved from a simple C subset into an independent language with its own unique syntax. All core features are implemented and have passed end-to-end testing.
1. Modern Syntax

CScript adopts a clearer and less error-prone type-after syntax:

    Variable Declarations: variable_name: type = value;

    x: i32 = 10;
    PI: f64 = 3.14;

    Function Definitions: function_name(param: type) -> return_type { ... }

    add(a: i32, b: i32) -> i32 {
        return a + b;
    }

2. Rich Primitive Type System

    Signed Integers: i8, i16, i32 (or int), i64

    Unsigned Integers: u8, u16, u32, u64

    Floating-Point Numbers: f32, f64

    Other Types: char, bool, void

    Pointers: Supports pointers to any level, e.g., i32*, char**.

3. Statements

    Variable Declarations: Supports local and global variable declarations with initializers.

    const qualifier.

    Control Flow:

        if / else conditional statements.

        while loop statements.

        Block Statements: Supports arbitrarily nested code blocks { ... } as standalone statements.

    Jump Statements: return, break, continue.

    Expression Statements: Any valid expression followed by a semicolon.

4. Expressions

    Literals:

        Integer Literals: Type is determined by the context (e.g., in x: u8 = 10;, 10 is inferred as u8).

        Float Literals: (e.g., 3.14159).

        Boolean Literals: true, false.

        String Literals: ("hello", with type char*).

    Operators:

        Arithmetic: +, -, *, /, % (supports both integers and floats).

        Comparison: ==, !=, >, <, >=, <= (supports both integers and floats).

        Logical: &&, || (Note: short-circuiting is not yet implemented).

        Unary: - (negation), ! (logical not), & (address-of), * (dereference).

        Assignment: =.

    Function Calls: Supports function calls with arguments.

5. Other Core Features

    Scoping: Correctly handles global, function, and block scopes.

    Type Safety: Performs strict type checking at compile-time, including overflow checks for numeric literals.

    Comments: Supports single-line // and multi-line /* ... */ comments.

Major Unsupported Features

    struct, union, enum

    Array declaration and access

    for loops (can be emulated with while)

    typedef and type aliases

    Explicit type casting

    A preprocessor

Installation
Build from Source

    Ensure you have the Rust toolchain and clang installed.

    Clone this repository:

    git clone https://github.com/karesis/cscript.git
    cd cscript

    Build the release executable:

    cargo build --release

    The executable will be located at target/release/cscript.

Usage

Assume you have a fib.c file written in the new CScript syntax:

// fib.c
// A Fibonacci function written in CScript's modern syntax.

fib(n: i32) -> i32 {
    if (n < 2) {
        return n;
    }
    return fib(n - 1) + fib(n - 2);
}

main() -> i32 {
    return fib(10); // The result should be 55
}

Compile to an Executable

# The default output name will be 'fib'
cargo run -- fib.c

# Run the program
./fib
echo $? # Should output 55

Specify an Output Filename

cargo run -- fib.c -o my_fib_program
./my_fib_program
echo $? # Should output 55

Emit LLVM IR

If you want to inspect the intermediate representation generated by the compiler, use the -S or --emit-llvm flag.

cargo run -- fib.c -S -o fib.ll

This will generate a text file named fib.ll containing the LLVM IR corresponding to fib.c.
Future Plans

Our journey has just begun!

    [ ] Advanced Data Structures: Implement full support for struct and arrays.

    [ ] Type Inference: Introduce the let keyword for variable declarations, enabling inference like let x = 10;.

    [ ] Module System: Design and implement a simple file-based module system.

    [ ] Optimization & Performance: Integrate more LLVM optimization passes and profile the compiler itself for performance improvements.

    [ ] Language Ecosystem: Explore the possibility of building a standard library, a package manager, and more.

We welcome contributions of all kinds. Let's build an exciting new language together!